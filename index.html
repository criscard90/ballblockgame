<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Arkanoid Ultra</title>
    <link rel="manifest" href="manifest.json">
    <style>
        body { margin: 0; background: #050505; color: #fff; overflow: hidden; font-family: 'Segoe UI', sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 2px solid #0ff; box-shadow: 0 0 20px #0ff; background: #000; max-width: 100%; max-height: 100%; cursor: none; }
        #ui { position: absolute; top: 10px; left: 10px; pointer-events: none; text-shadow: 0 0 5px #0ff; font-weight: bold; z-index: 5; }
        #gameOverScreen { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0,0,0,0.9); padding: 30px; border: 2px solid #0ff; box-shadow: 0 0 30px #0ff; z-index: 10; }
        button { background: #0ff; border: none; padding: 10px 25px; font-weight: bold; color: #000; cursor: pointer; margin-top: 15px; }
        .stat { color: #0ff; margin-right: 15px; }
    </style>
</head>
<body>

    <div id="ui">
        LIVELLO: <span id="level" class="stat">1</span>
        PUNTI: <span id="score" class="stat">0</span><br>
        VITE: <span id="lives" class="stat">3</span>
        COMBO: <span id="combo" class="stat">x1</span>
    </div>
    
    <div id="gameOverScreen">
        <h1 style="color: #0ff;">GAME OVER</h1>
        <p>Punteggio Finale: <span id="finalScore">0</span></p>
        <button onclick="location.reload()">RIPROVA</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score'), levelEl = document.getElementById('level');
        const livesEl = document.getElementById('lives'), comboEl = document.getElementById('combo');

        canvas.width = window.innerWidth < 500 ? window.innerWidth - 20 : 480;
        canvas.height = window.innerHeight < 800 ? window.innerHeight - 100 : 640;

        let score = 0, lives = 3, currentLevel = 1, combo = 1, gameRunning = true, shakeTime = 0, laserTimer = 0, bombActive = false, prevPaddleX = canvas.width / 2 - 45;
        const paddle = { w: 90, h: 12, x: canvas.width / 2 - 45, y: canvas.height - 30, color: '#0ff', dx: 0 };
        let balls = [], bricks = [], powerUps = [], particles = [], floatingTexts = [], lasers = [];
        let stars = Array.from({length: 40}, () => ({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2, speed: Math.random() * 0.5 + 0.1 }));

        const brickConfig = { rows: 4, cols: 6, h: 25, padding: 8, offsetTop: 60 };

        function createBall(x, y, isExtra = false) {
            const angle = isExtra ? (Math.random() * Math.PI) - Math.PI : -Math.PI/4;
            const speed = 4 + (currentLevel * 0.2);
            return { radius: 7, x, y, dx: isExtra ? Math.cos(angle) * speed : speed, dy: isExtra ? Math.sin(angle) * speed : -speed, speed, color: '#fff', isFire: false, fireTimer: 0, trail: [] };
        }

        function spawnText(x, y, txt, color) { floatingTexts.push({ x, y, txt, color, life: 1.0 }); }
        function createParticles(x, y, color) { for (let i = 0; i < 8; i++) particles.push({ x, y, dx: (Math.random()-0.5)*6, dy: (Math.random()-0.5)*6, life: 1.0, color }); }
        function startShake(duration) { shakeTime = duration; }

        function generateLevel() {
            bricks = [];
            const colors = ['#f0f', '#0ff', '#0f0', '#ff0', '#f00'];
            let rows = Math.min(brickConfig.rows + Math.floor(currentLevel/2), 8);
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < brickConfig.cols; c++) {
                    let rand = Math.random(), type = 'normal', hits = 1, color = colors[r % colors.length];
                    if (rand < 0.1) { type = 'steel'; color = '#888'; hits = 999; }
                    else if (rand < 0.25) { type = 'heavy'; color = '#ffa500'; hits = 3; }
                    bricks.push({ x: c * (canvas.width / brickConfig.cols) + 4, y: r * (brickConfig.h + 8) + 60, w: (canvas.width / brickConfig.cols) - 8, h: 25, color, origColor: color, type, hits, status: 1 });
                }
            }
        }

        function movePaddle(clientX) {
            const rect = canvas.getBoundingClientRect();
            let newX = clientX - rect.left - paddle.w/2;
            newX = Math.max(0, Math.min(canvas.width - paddle.w, newX));
            paddle.dx = newX - paddle.x;
            paddle.x = newX;
        }
        canvas.addEventListener('mousemove', (e) => movePaddle(e.clientX));
        canvas.addEventListener('touchmove', (e) => { movePaddle(e.touches[0].clientX); e.preventDefault(); }, {passive: false});

        function update() {
            if (!gameRunning) return;
            if (shakeTime > 0) shakeTime--;
            stars.forEach(s => { s.y += s.speed; if(s.y > canvas.height) s.y = 0; });

            for (let i = balls.length - 1; i >= 0; i--) {
                let b = balls[i];
                b.trail.unshift({x: b.x, y: b.y}); if(b.trail.length > 8) b.trail.pop();
                b.x += b.dx; b.y += b.dy;

                if (b.x + b.radius >= canvas.width) { b.dx = -Math.abs(b.dx); b.x = canvas.width - b.radius; startShake(2); }
                else if (b.x - b.radius <= 0) { b.dx = Math.abs(b.dx); b.x = b.radius; startShake(2); }
                if (b.y - b.radius <= 0) { b.dy = Math.abs(b.dy); b.y = b.radius; startShake(2); }
                if (b.y + b.radius > paddle.y && b.y < paddle.y + paddle.h && b.x > paddle.x && b.x < paddle.x + paddle.w) {
                    let hitPos = (b.x - paddle.x) / paddle.w;
                    let angleFactor = (hitPos - 0.5) * 2; // -1 to 1
                    b.dx = angleFactor * b.speed * 1.2 + paddle.dx * 0.1; // spin
                    b.dy = -Math.abs(b.dy);
                    let len = Math.sqrt(b.dx*b.dx + b.dy*b.dy);
                    if (len > 0) {
                        b.dx /= len; b.dy /= len;
                        let newSpeed = Math.max(3, Math.min(8, len));
                        b.dx *= newSpeed; b.dy *= newSpeed;
                        b.speed = newSpeed;
                    }
                    combo = 1; comboEl.innerText = "x1";
                }

                bricks.forEach(brick => {
                    if (brick.status === 1 && b.x + b.radius > brick.x && b.x - b.radius < brick.x + brick.w && b.y + b.radius > brick.y && b.y - b.radius < brick.y + brick.h) {
                        if (!b.isFire || brick.type === 'steel') {
                            let hitSide = Math.abs(b.x - (brick.x + brick.w/2)) / (brick.w/2 + b.radius) > Math.abs(b.y - (brick.y + brick.h/2)) / (brick.h/2 + b.radius);
                            if (hitSide) b.dx *= -1; else b.dy *= -1;
                        }
                        if (brick.type !== 'steel') {
                            if (b.isFire) { brick.hits = 0; startShake(12); }
                            else { brick.hits--; startShake(5); }

                            if (brick.hits <= 0) {
                                brick.status = 0; let pts = (brick.type === 'heavy' ? 30 : 10) * combo;
                                score += pts; spawnText(brick.x, brick.y, "+" + pts, brick.origColor);
                                combo++; scoreEl.innerText = score; comboEl.innerText = "x" + combo;
                                createParticles(brick.x + brick.w/2, brick.y + brick.h/2, brick.origColor);
                                if (bombActive) {
                                    const bx = brick.x + brick.w/2, by = brick.y + brick.h/2;
                                    bricks.forEach(b => {
                                        if (b.status === 1 && b.type !== 'steel' && Math.hypot(b.x + b.w/2 - bx, b.y + b.h/2 - by) < 60) {
                                            b.hits = 0; b.status = 0;
                                            score += (b.type === 'heavy' ? 30 : 10) * combo;
                                            spawnText(b.x, b.y, "+" + ((b.type === 'heavy' ? 30 : 10) * combo), b.origColor);
                                            createParticles(b.x + b.w/2, b.y + b.h/2, b.origColor);
                                        }
                                    });
                                    bombActive = false;
                                }
                                if (Math.random() < 0.15) {
                                    const types = ['multi', 'fire', 'enlarge', 'slow', 'life', 'laser', 'bomb'];
                                    const colors = ['#f0f', '#ff4500', '#0f0', '#00f', '#ff0', '#ff0', '#800'];
                                    const idx = Math.floor(Math.random() * types.length);
                                    powerUps.push({ x: brick.x + brick.w/2, y: brick.y, type: types[idx], color: colors[idx] });
                                }
                            }
                        }
                    }
                });
                if (b.isFire) { b.fireTimer--; if(b.fireTimer <= 0) b.isFire = false; }
                if (b.y > canvas.height) balls.splice(i, 1);
            }

            if (balls.length === 0) {
                lives--; livesEl.innerText = lives;
                if (lives > 0) { balls.push(createBall(canvas.width/2, paddle.y - 15)); combo = 1; comboEl.innerText = "x1"; }
                else { gameRunning = false; document.getElementById('gameOverScreen').style.display = 'block'; document.getElementById('finalScore').innerText = score; }
            }

            if (laserTimer > 0) {
                laserTimer--;
                if (laserTimer % 30 === 0) lasers.push({x: paddle.x + paddle.w/2, y: paddle.y, dy: -10});
            }
            lasers.forEach((l, i) => {
                l.y += l.dy;
                bricks.forEach(brick => {
                    if (brick.status === 1 && l.x > brick.x && l.x < brick.x + brick.w && l.y > brick.y && l.y < brick.y + brick.h) {
                        if (brick.type !== 'steel') {
                            brick.hits = 0;
                            brick.status = 0; let pts = (brick.type === 'heavy' ? 30 : 10) * combo;
                            score += pts; spawnText(brick.x, brick.y, "+" + pts, brick.origColor);
                            combo++; scoreEl.innerText = score; comboEl.innerText = "x" + combo;
                            createParticles(brick.x + brick.w/2, brick.y + brick.h/2, brick.origColor);
                        }
                        lasers.splice(i, 1);
                    }
                });
                if (l.y < 0) lasers.splice(i, 1);
            });

            for (let i = powerUps.length - 1; i >= 0; i--) {
                let p = powerUps[i]; p.y += 3;
                if (p.y > paddle.y && p.y < paddle.y + paddle.h && p.x > paddle.x && p.x < paddle.x + paddle.w) {
                    if (p.type === 'multi') { balls.push(createBall(paddle.x, paddle.y-10, true)); balls.push(createBall(paddle.x, paddle.y-10, true)); }
                    else if (p.type === 'fire') { balls.forEach(b => { b.isFire = true; b.fireTimer = 400; }); startShake(15); }
                    else if (p.type === 'enlarge') { paddle.w += 30; setTimeout(() => paddle.w = Math.max(90, paddle.w - 30), 8000); }
                    else if (p.type === 'slow') { balls.forEach(b => b.speed *= 0.7); setTimeout(() => balls.forEach(b => b.speed /= 0.7), 6000); }
                    else if (p.type === 'life') { lives++; livesEl.innerText = lives; }
                    else if (p.type === 'laser') { laserTimer = 600; }
                    else if (p.type === 'bomb') { bombActive = true; }
                    powerUps.splice(i, 1);
                } else if (p.y > canvas.height) powerUps.splice(i, 1);
            }

            floatingTexts.forEach((t, i) => { t.y -= 1; t.life -= 0.02; if(t.life <= 0) floatingTexts.splice(i,1); });
            particles.forEach((p, i) => { p.x += p.dx; p.y += p.dy; p.life -= 0.02; if (p.life <= 0) particles.splice(i, 1); });

            if (bricks.length > 0 && bricks.filter(b => b.status === 1 && b.type !== 'steel').length === 0) {
                currentLevel++; levelEl.innerText = currentLevel; generateLevel();
                balls = [createBall(canvas.width/2, paddle.y - 15)];
            }
        }

        function draw() {
            ctx.save();
            if (shakeTime > 0) ctx.translate((Math.random()-0.5)*8, (Math.random()-0.5)*8);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#fff"; stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));

            bricks.forEach(b => {
                if (b.status === 1) {
                    ctx.shadowBlur = 10; ctx.shadowColor = b.color; ctx.fillStyle = b.color;
                    ctx.fillRect(b.x, b.y, b.w, b.h);
                    if (b.type === 'heavy') {
                        ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(b.x + 2, b.y + b.h - 6, b.w - 4, 4);
                        ctx.fillStyle = "#fff"; ctx.fillRect(b.x + 2, b.y + b.h - 6, (b.w - 4) * (b.hits / 3), 4);
                    }
                }
            });

            balls.forEach(b => {
                b.trail.forEach((pos, idx) => {
                    ctx.fillStyle = b.isFire ? `rgba(255,69,0,${0.5-idx/16})` : `rgba(255,255,255,${0.3-idx/20})`;
                    ctx.beginPath(); ctx.arc(pos.x, pos.y, b.radius - idx, 0, Math.PI*2); ctx.fill();
                });
                ctx.shadowBlur = b.isFire ? 20 : 10; ctx.shadowColor = b.isFire ? '#f40' : '#fff';
                ctx.fillStyle = b.isFire ? '#f40' : '#fff';
                ctx.beginPath(); ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2); ctx.fill();
            });

            ctx.shadowBlur = 15; ctx.shadowColor = '#0ff'; ctx.fillStyle = '#0ff';
            ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

            lasers.forEach(l => {
                ctx.shadowBlur = 10; ctx.shadowColor = '#ff0'; ctx.fillStyle = '#ff0';
                ctx.fillRect(l.x - 1, l.y, 2, 10);
            });

            powerUps.forEach(p => {
                ctx.shadowBlur = 15; ctx.shadowColor = p.color; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center';
                let icon = '';
                if (p.type === 'multi') icon = '+';
                else if (p.type === 'fire') icon = 'F';
                else if (p.type === 'enlarge') icon = 'E';
                else if (p.type === 'slow') icon = 'S';
                else if (p.type === 'life') icon = 'L';
                else if (p.type === 'laser') icon = 'Z';
                else if (p.type === 'bomb') icon = 'B';
                ctx.fillText(icon, p.x, p.y + 5);
            });

            ctx.shadowBlur = 0;
            floatingTexts.forEach(t => { ctx.fillStyle = `rgba(${hexToRgb(t.color)},${t.life})`; ctx.font = "bold 15px sans-serif"; ctx.fillText(t.txt, t.x, t.y); });
            particles.forEach(p => { ctx.fillStyle = `rgba(${hexToRgb(p.color)},${p.life})`; ctx.fillRect(p.x, p.y, 3, 3); });
            ctx.restore();
        }

        function hexToRgb(h) {
            const r = parseInt(h.slice(1,3), 16), g = parseInt(h.slice(3,5), 16), b = parseInt(h.slice(5,7), 16);
            return `${r},${g},${b}`;
        }

        function loop() { update(); draw(); requestAnimationFrame(loop); }
        generateLevel(); balls.push(createBall(canvas.width/2, paddle.y-15)); loop();
    </script>
</body>
</html>
